# -*- coding: utf-8 -*-

# This file was *autogenerated* from the file cycle_iterator.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_9 = Integer(9); _sage_const_8 = Integer(8); _sage_const_13 = Integer(13); _sage_const_12 = Integer(12); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_17 = Integer(17); _sage_const_16 = Integer(16); _sage_const_15 = Integer(15); _sage_const_14 = Integer(14); _sage_const_18 = Integer(18)####### D'aprÃ¨s l'article : https://arxiv.org/pdf/1205.2766.pdf #######
import numpy as np

def cycles_iterator(g):
    seen = set()
    same_cycle_different_paths = set()

    #Decomposition into biconnected components
    cut_edges = g.bridges()
    if len(cut_edges) > _sage_const_0 :
        #There is at least one articulation point
        g.delete_edges(cut_edges)

    ccs = np.array(g.connected_components()) #fill the connected components list

    #Edges list for each cc : cc_edges[0] =  edges list associated to ccs[0] vertices list
    cc_edges = [[] for i in range(len(ccs))]
    for e in g.edges():
        for i, cc in enumerate(ccs):
            if e[_sage_const_0 ] in cc:
                cc_edges[i].append(e)

    #For each connected component, we extract simple cycles by removing back edges
    #and listing all path from start to end of the removed edge
    for i, cc in enumerate(ccs):
        sg = g.subgraph(edges=cc_edges[i]) #subgragh with current connected component edges only
        #For each edge e of the current connected component
        for e in cc_edges[i]:
            if e[_sage_const_1 ] in seen: #e is a back edge
                #g.delete_edge(e)
                sg.delete_edge(e)
                cycles = sg.all_paths(e[_sage_const_0 ], e[_sage_const_1 ])

                #There are duplicates for some simple cycles,
                #there can be 2 different paths for the same cycle
                for c in cycles:
                    sorted_cycle = tuple(sorted(c))
                    if sorted_cycle not in same_cycle_different_paths:
                        same_cycle_different_paths.add(sorted_cycle)
                        yield c
            seen.add(e[_sage_const_1 ])


########## testing graphs ##########
g = Graph()
g.add_vertices([_sage_const_1 ,_sage_const_2 ,_sage_const_3 ,_sage_const_4 ,_sage_const_5 ,_sage_const_6 ,_sage_const_7 ,_sage_const_8 ,_sage_const_9 ])
g.add_edges([(_sage_const_1 ,_sage_const_2 ), (_sage_const_2 ,_sage_const_3 ), (_sage_const_3 ,_sage_const_4 ), (_sage_const_4 ,_sage_const_9 ), (_sage_const_4 ,_sage_const_5 ), (_sage_const_5 ,_sage_const_6 ), (_sage_const_6 ,_sage_const_2 ), (_sage_const_1 ,_sage_const_7 ), (_sage_const_7 ,_sage_const_8 ), (_sage_const_8 ,_sage_const_9 )])

g2 = Graph()
g2.add_vertices(range(_sage_const_1 ,_sage_const_18 ))
g2.add_edges([(_sage_const_1 , _sage_const_2 ),(_sage_const_1 , _sage_const_3 ),(_sage_const_2 , _sage_const_3 ),(_sage_const_3 , _sage_const_4 ),(_sage_const_4 , _sage_const_5 ),(_sage_const_4 , _sage_const_11 ),(_sage_const_5 , _sage_const_6 ),(_sage_const_5 , _sage_const_13 ),(_sage_const_5 , _sage_const_15 ),(_sage_const_6 , _sage_const_7 ),(_sage_const_7 , _sage_const_8 ),(_sage_const_8 , _sage_const_9 ),(_sage_const_9 , _sage_const_10 ),(_sage_const_10 , _sage_const_11 ),(_sage_const_12 , _sage_const_13 ),(_sage_const_12 , _sage_const_14 ),(_sage_const_13 , _sage_const_14 ),(_sage_const_15 , _sage_const_16 ),(_sage_const_15 , _sage_const_17 ),(_sage_const_16 , _sage_const_17 )])
g2.add_edges([(_sage_const_6 ,_sage_const_10 ), (_sage_const_7 ,_sage_const_10 )])

g4 = graphs.CompleteGraph(_sage_const_10 )

g5 = graphs.PetersenGraph()


def main():
    cycles = cycles_iterator(g5)
    for i, c in enumerate(cycles):
        print "{} : {}".format(i+_sage_const_1 , c)

main()

