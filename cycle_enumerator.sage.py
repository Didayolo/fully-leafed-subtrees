# -*- coding: utf-8 -*-

# This file was *autogenerated* from the file cycle_enumerator.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_9 = Integer(9); _sage_const_8 = Integer(8); _sage_const_13 = Integer(13); _sage_const_12 = Integer(12); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_17 = Integer(17); _sage_const_16 = Integer(16); _sage_const_15 = Integer(15); _sage_const_14 = Integer(14); _sage_const_18 = Integer(18)####### D'après l'article : https://arxiv.org/pdf/1205.2766.pdf #######

def is_back_edge(edge, seen):
	return edge[_sage_const_1 ] in seen


def recursive_cycles_iterator(g):
	def slave(g, acc):
		edges = g.edges()
		cut_edges = g.bridges()

		seen = set()

		print "##### RECURSIVE CALL #####"
		if(len(edges) > _sage_const_2 ): #no cycles with less than 3 edges
			if len(cut_edges) > _sage_const_0 : #there is at least one articulation point
				new_edges = filter(lambda x: x not in cut_edges, edges)
				sccs = g.subgraph(edges=new_edges)
				slave(sccs, acc)
			else:
				for e in edges:
					if is_back_edge(e, seen):
						print "{} is a back edge".format(e)
						edges_copy = g.edges()
						edges_copy.remove(e)
						g2 = g.subgraph(edges=edges_copy)
						cycles = g2.all_paths(e[_sage_const_0 ], e[_sage_const_1 ])
						print "### cycles : {}".format(cycles)
						for c in cycles:
							c = sorted(c)
							#yield c
							acc.add(tuple(c))
						slave(g2, acc)
					seen.add(e[_sage_const_1 ])
			return acc
		else:
			return set()


	return slave(g, set())


def cycles_iterator(g):
	seen = set()
	same_cycle_different_paths = set()

	cut_edges = g.bridges()
	if len(cut_edges) > _sage_const_0 : #there is at least one articulation point
		g.delete_edges(cut_edges)

	ccs = g.connected_components() #fill the connected components list

	for cc in ccs:
		cc_edges = [e for e in g.edges() if e[_sage_const_0 ] in cc and e[_sage_const_1 ] in cc] #useful if ccs has more than 1 cc
		for e in cc_edges:
			if is_back_edge(e, seen): #faster without function ??
				g.delete_edge(e)
				cycles = g.all_paths(e[_sage_const_0 ], e[_sage_const_1 ])

				for c in cycles:
					sorted_cycle = tuple(sorted(c))
					if sorted_cycle not in same_cycle_different_paths:
						same_cycle_different_paths.add(sorted_cycle)
						yield c
				cycles = []
			seen.add(e[_sage_const_1 ])

		#there are more than 2 edges and at least one cycle found, either way there are no more cycles
		#if(len(g.edges()) > 2 and cycles != []): 
		#	ccs.append(g.vertices())
		#	seen = set()



def naive_all_cycles_iterator(g):
	"""
		A AMELIORER :
			-passer des composantes connexes a la fonction au lieu d'un cycle ?
			-faire un générateur directement (sans passer par un set anti-doublon et un tri)
	"""
	edges = g.edges(labels=False)
	#print "edges : {}".format(edges)
	seen = set()
	ret = set()

	for edge in edges: 
		if g.is_cut_edge(edge):
			#print "{} is a cut edge".format(edge)
			edges_copy = g.edges(labels=False)
			edges_copy.remove(edge)
			g2 = g.subgraph(edges=edges_copy)
			naive_all_cycles_iterator(g2)

		elif is_back_edge(edge, seen):
			#print "{} is a back edge".format(edge)
			edges_copy = g.edges(labels=False)
			edges_copy.remove(edge)
			g2 = g.subgraph(edges=edges_copy)
			cycles = g2.all_paths(edge[_sage_const_0 ], edge[_sage_const_1 ])
			for c in cycles:
				c = sorted(c)
				#print c
				#yield c
				ret.add(tuple(c))
		seen.add(edge[_sage_const_1 ])

	return ret


########## testing graphs ##########
g = Graph()
g.add_vertices([_sage_const_1 ,_sage_const_2 ,_sage_const_3 ,_sage_const_4 ,_sage_const_5 ,_sage_const_6 ,_sage_const_7 ,_sage_const_8 ,_sage_const_9 ])
g.add_edges([(_sage_const_1 ,_sage_const_2 ), (_sage_const_2 ,_sage_const_3 ), (_sage_const_3 ,_sage_const_4 ), (_sage_const_4 ,_sage_const_9 ), (_sage_const_4 ,_sage_const_5 ), (_sage_const_5 ,_sage_const_6 ), (_sage_const_6 ,_sage_const_2 ), (_sage_const_1 ,_sage_const_7 ), (_sage_const_7 ,_sage_const_8 ), (_sage_const_8 ,_sage_const_9 )])

g2 = Graph()
g2.add_vertices(range(_sage_const_1 ,_sage_const_18 ))
g2.add_edges([(_sage_const_1 , _sage_const_2 ),(_sage_const_1 , _sage_const_3 ),(_sage_const_2 , _sage_const_3 ),(_sage_const_3 , _sage_const_4 ),(_sage_const_4 , _sage_const_5 ),(_sage_const_4 , _sage_const_11 ),(_sage_const_5 , _sage_const_6 ),(_sage_const_5 , _sage_const_13 ),(_sage_const_5 , _sage_const_15 ),(_sage_const_6 , _sage_const_7 ),(_sage_const_7 , _sage_const_8 ),(_sage_const_8 , _sage_const_9 ),(_sage_const_9 , _sage_const_10 ),(_sage_const_10 , _sage_const_11 ),(_sage_const_12 , _sage_const_13 ),(_sage_const_12 , _sage_const_14 ),(_sage_const_13 , _sage_const_14 ),(_sage_const_15 , _sage_const_16 ),(_sage_const_15 , _sage_const_17 ),(_sage_const_16 , _sage_const_17 )])

g3 = Graph()
g3.add_vertices(range(_sage_const_1 ,_sage_const_18 ))
g3.add_edges([(_sage_const_1 , _sage_const_2 ),(_sage_const_1 , _sage_const_3 ),(_sage_const_2 , _sage_const_3 ),(_sage_const_3 , _sage_const_4 ),(_sage_const_4 , _sage_const_5 ),(_sage_const_4 , _sage_const_11 ),(_sage_const_5 , _sage_const_6 ),(_sage_const_5 , _sage_const_13 ),(_sage_const_5 , _sage_const_15 ),(_sage_const_6 , _sage_const_7 ),(_sage_const_7 , _sage_const_8 ),(_sage_const_8 , _sage_const_9 ),(_sage_const_9 , _sage_const_10 ),(_sage_const_10 , _sage_const_11 ),(_sage_const_12 , _sage_const_13 ),(_sage_const_12 , _sage_const_14 ),(_sage_const_13 , _sage_const_14 ),(_sage_const_15 , _sage_const_16 ),(_sage_const_15 , _sage_const_17 ),(_sage_const_16 , _sage_const_17 )])
g3.add_edges([(_sage_const_6 ,_sage_const_10 ), (_sage_const_7 ,_sage_const_10 )])

g4 = graphs.CompleteGraph(_sage_const_9 )

g5 = graphs.PetersenGraph()

def test1():
	cycles = cycles_iterator(g5)
	for i, c in enumerate(cycles):
		print "{} : {}".format(i+_sage_const_1 , c)

def test2():
	cycles = naive_all_cycles_iterator(g5)
	for i, c in enumerate(cycles):
		print "{} : {}".format(i+_sage_const_1 , c)


def main():
	test1()

main()

